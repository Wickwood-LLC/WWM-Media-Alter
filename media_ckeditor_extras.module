<?php

/**
 * Implements hook_help().
 */
function media_ckeditor_extras_help($path, $arg) {
  global $basePath;
  $output = '';
  switch ($path) {
    case 'admin/help#media_ckeditor_extras':
      // We keep help text in separate file instead writing that long text here.
      // Otherwise the long help text would be read by PHP engine and kept in memory, which bad to have.
      $output = theme_render_template(
        drupal_get_path('module', 'media_ckeditor_extras') . '/help.tpl.php',
        array('basePath' => $basePath)
      );
  }
  return $output;
}

/**
 * Helper function to return all fields of one type on one bundle.
 */
function media_ckeditor_extras_fields_by_type_by_bundle($entity_type, $bundle = NULL, $type = NULL) {
  $chosen_fields = array();
  $fields = field_info_field_map();
  foreach ($fields as $field => $info) {
    if ($info['type'] == $type &&
        in_array($entity_type, array_keys($info['bundles'])) &&
        (empty($bundle) || in_array($bundle, $info['bundles'][$entity_type]))
    ){
      $chosen_fields[$field] = $field;
    }
  }
  return $chosen_fields;
}

/**
 * Helper function to return CSS classes and styles to be used for the entity.
 */
function media_ckeditor_extras_get_css_classes_and_styles($entity_type, $entity) {
  $output = array('class' => array(), 'styles' => '');
  list(, , $bundle) = entity_extract_ids($entity_type, $entity);
  $wrapper = entity_metadata_wrapper($entity_type, $entity);
  $css_fields = media_ckeditor_extras_fields_by_type_by_bundle($entity_type, $bundle, 'css_class');

  foreach ($css_fields as $field_name) {
    if (isset($wrapper->{$field_name})) {
      $class = $wrapper->{$field_name}->value();
      if (!empty($class) && $class != '_none') {
        $output['class'][] = $class;
        $field = field_info_field($field_name);
        if (!empty($field['settings']['css_style_text'])) {
          $output['styles'] .= "\n" . $field['settings']['css_style_text'];
        }
      }
    }
  }
  return $output;
}


/**
 * Implements hook_media_wysiwyg_token_to_markup_alter().
 */
function media_ckeditor_extras_media_wysiwyg_token_to_markup_alter(&$element, $tag_info, $settings) {
  $file = $tag_info['file'];

  if (empty($file)) {
    return;
  }
  $entity_type = 'file';
  // Add classes for image when entity is viewed.
  if (empty($settings['wysiwyg'])) {
    $css_data = media_ckeditor_extras_get_css_classes_and_styles($entity_type, $file);
    // For some elements it may be just string. So convert to array for merging.
    // Specific use of this one is when 'Field Formatter Class' used in field to sepcify class name in simple textfield.
    if (!is_array($element['content']['#attributes']['class'])) {
      $element['content']['#attributes']['class'] = array($element['content']['#attributes']['class']);
    }
    $element['content']['#attributes']['class'] = array_merge($element['content']['#attributes']['class'], $css_data['class']);
    drupal_add_css($css_data['styles'], array('type' => 'inline'));
  }
}

/**
 * Implements hook_preprocess_HOOK()
 */
function media_ckeditor_extras_preprocess_file_entity(&$variables) {
  if (isset($variables['file']->override['wysiwyg']) && $variables['file']->override['wysiwyg']) {
    $entity_type = 'file';
    $css_data = media_ckeditor_extras_get_css_classes_and_styles($entity_type, $variables['file']);
    $variables['classes_array'] = isset($variables['classes_array']) ? $variables['classes_array'] : array();
    $variables['classes_array'] = array_merge($variables['classes_array'], $css_data['class']);
    drupal_add_css($css_data['styles'], array('type' => 'inline'));
    drupal_add_js(
      array(
        'media_ckeditor_extras' => array(
          'styles' => array(
            "$entity_type.{$variables['file']->fid}" => $css_data['styles']
          ),
        )
      ),
      'setting'
    );
  }
  // Link media to the URL that given in selected link field.
  $link_field_name = variable_get("media_ckeditor_extras_file_{$variables['type']}_link", '_none');
  if (!empty($link_field_name) && $link_field_name != '_none') {
    $file_wrapper = entity_metadata_wrapper('file', $variables['file']);
    if (isset($file_wrapper->{$link_field_name})) {
      $link = $file_wrapper->{$link_field_name}->value();
      // Ensure we are altering data for 'image_formatter' theme to avoid surprices.
      if (!empty($link['url'])) {
        if ($variables['content']['file']['#theme'] == 'image_style') {
          $old_file_renderable = $variables['content']['file'];
          $variables['content']['file'] = array();
          $variables['content']['file']['#theme'] = 'image_formatter';
          $variables['content']['file']['#item'] = array();
          $variables['content']['file']['#item']['uri'] = $old_file_renderable['#path'];
          if (!empty($old_file_renderable['#width'])) {
            $variables['content']['file']['#item']['width'] = $old_file_renderable['#width'];
          }
          if (!empty($old_file_renderable['#height'])) {
            $variables['content']['file']['#item']['height'] = $old_file_renderable['#height'];
          }
          if (!empty($old_file_renderable['#alt'])) {
            $variables['content']['file']['#item']['alt'] = $old_file_renderable['#alt'];
          }
          if (!empty($old_file_renderable['#title'])) {
            $variables['content']['file']['#item']['title'] = $old_file_renderable['#title'];
          }
          if (!empty($old_file_renderable['#attributes'])) {
            $variables['content']['file']['#item']['attributes'] = $old_file_renderable['#attributes'];
          }

          $variables['content']['file']['#image_style'] = $old_file_renderable['#style_name'];
        }
        if ($variables['content']['file']['#theme'] == 'image_formatter') {
          $variables['content']['file']['#path']['path'] = $link['url'];
          if (!empty($link['attributes']['target'])) {
            $variables['content']['file']['#path']['options']['attributes']['target'] = $link['attributes']['target'];
          }
          if (!empty($link['attributes']['class'])) {
            $variables['content']['file']['#path']['options']['attributes']['class'][] = $link['attributes']['class'];
          }
        }
      }
    }
  }
}

/**
 * Implements hook_field_info().
 */
function media_ckeditor_extras_field_info() {
  return array(
    'css_class' => array(
      'label' => t('CSS Class'),
      'description' => t("This field stores text values from a list of allowed 'value => label' pairs, i.e. 'US States': IL => Illinois, IA => Iowa, IN => Indiana."),
      'settings' => array('allowed_values' => array(), 'allowed_values_function' => '', 'css_style_text' => ''),
      'default_widget' => 'options_select',
      'default_formatter' => 'list_default',
      'property_type' => 'text',
      'property_callbacks' => array('media_ckeditor_extras_entity_metadata_field_property_callback'),
    ),
  );
}

/**
 * Callback to add in property info defaults per field instance.
 * @see entity_metadata_field_entity_property_info().
 */
function media_ckeditor_extras_entity_metadata_field_property_callback(&$info, $entity_type, $field, $instance, $field_type) {
  $name = $field['field_name'];
  $property = &$info[$entity_type]['bundles'][$instance['bundle']]['properties'][$name];
  entity_metadata_field_default_property_callback($info, $entity_type, $field, $instance, $field_type);
  $property['options list'] = 'entity_metadata_field_options_list';
}

/**
 * Implements hook_field_settings_form().
 */
function media_ckeditor_extras_field_settings_form($field, $instance, $has_data) {
  $field_clone = $field;
  // Set field type to list_text and get settings form.
  // So, we can duplicating that much code here.
  $field_clone['type'] = 'list_text';
  $form = list_field_settings_form($field_clone, $instance, $has_data);

  $settings = $field['settings'];
  $form['css_style_text'] = array(
    '#type' => 'textarea',
    '#title' => t('CSS styles'),
    '#description' => t('Provide CSS style text here. It will get includes as inline CSS as required.'),
    '#default_value' => $settings['css_style_text'],
    '#rows' => 10,
    '#field_has_data' => $has_data,
    '#field' => $field,
    '#field_type' => $field['type'],
  );

  return $form;
}

/**
 * Implements hook_field_widget_info_alter().
 *
 * This module does not implement widgets of its own, but reuses the
 * widgets defined in options.module.
 *
 * @see list_options_list()
 */
function media_ckeditor_extras_field_widget_info_alter(&$info) {
  $widgets = array(
    'options_select' => array('css_class'),
    'options_buttons' => array('css_class'),
  );

  foreach ($widgets as $widget => $field_types) {
    $info[$widget]['field types'] = array_merge($info[$widget]['field types'], $field_types);
  }
}

/**
 * Implements hook_field_formatter_info_alter().
 */
function media_ckeditor_extras_field_formatter_info_alter(&$info) {
  $info['list_default']['field types'][] = 'css_class';
  $info['list_key']['field types'][] = 'css_class';
}

/**
 * Implements hook_field_is_empty().
 */
function media_ckeditor_extras_field_is_empty($item, $field) {
  return list_field_is_empty($item, $field);
}

/**
 * Implements hook_options_list().
 */
function media_ckeditor_extras_options_list($field, $instance, $entity_type, $entity) {
  return list_allowed_values($field, $instance, $entity_type, $entity);
}

/**
 * Implements hook_form_FORM_ID_alter()
 */
function media_ckeditor_extras_form_file_entity_file_type_form_alter(&$form, $form_state) {
  // Now we have setting that only relevant to images.
  if ($form['#file_type']->type == 'image') {
    $form['media_ckeditor_extras'] = array(
      '#type' => 'fieldset',
      '#title' => t('Media CKEditor Extras'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );
    $options = array('_none' => t('None'));
    $link_fields = media_ckeditor_extras_fields_by_type_by_bundle('file', $form['#file_type']->type, 'link_field');
    foreach ($link_fields as $field_name) {
      $options[$field_name] = $field_name;
    }
    $form['media_ckeditor_extras']['media_ckeditor_extras_link'] = array(
      '#type' => 'select',
      '#title' => t('Link'),
      '#description' => t('Select the link field that will be used to link the image.'),
      '#options' => $options,
      '#default_value' => variable_get("media_ckeditor_extras_file_{$form['#file_type']->type}_link", '_none'),
      '#required' => FALSE,
    );

    $form['#submit'][] = 'media_ckeditor_extras_file_entity_file_type_form_submit';
  }
}

function media_ckeditor_extras_file_entity_file_type_form_submit($form, $form_state) {
  variable_set("media_ckeditor_extras_file_{$form['#file_type']->type}_link", $form_state['values']['media_ckeditor_extras_link']);
}

/**
 * Implements hook_ckeditor_settings_alter()
 */
function media_ckeditor_extras_ckeditor_settings_alter(&$settings, $conf) {
  // Load CSS styles from 'CSS Class' fields and add them to JS settings.
  // Those styles will be loaded within CKEditor by editor_plugin/plugin.js file.
  $css_fields = media_ckeditor_extras_fields_by_type_by_bundle('file', NULL, 'css_class');
  $styles = '';
  foreach ($css_fields as $field_name) {
    $field = field_info_field($field_name);
    if (!empty($field['settings']['css_style_text'])) {
      $styles .= "\n" . $field['settings']['css_style_text'];
    }
  }
  $js_setting = array(
    'media_ckeditor_extras' => array(
      'styles' => array(
        'file' => $styles,
      ),
    )
  );

  // Enable lazyloading of responsive images within CKEditor.
  if (module_exists('picture')) {
    $js_setting['media_ckeditor_extras']['lazysizes_path'] = drupal_get_path('module', 'picture') . '/lazysizes/lazysizes.js';
  }
  drupal_add_js(
    $js_setting,
    'setting'
  );
  global $base_path;
  $settings['contentsCss'][] = $base_path . drupal_get_path('module', 'media_ckeditor_extras') . '/css/media-ckeditor-extras.css';
}

/**
 * Add CSS styles defined in given CSS Class field.
 *
 * @param string $field_name
 *  CSS Class field name.
 */
function media_ckeditor_extras_add_styles_for_css_field($field_name) {
  $processed_fields = &drupal_static(__FUNCTION__, array());
  if (!isset($processed_fields[$field_name])) {
    $processed_fields[$field_name] = TRUE;
    $styles = '';
    $field = field_info_field($field_name);
    if (!empty($field['settings']['css_style_text'])) {
      $styles .= "\n" . $field['settings']['css_style_text'];
    }
    drupal_add_css($styles, array('type' => 'inline'));
  }
}

/**
 * Implements hook_entity_view().
 */
function media_ckeditor_extras_entity_view($entity, $type, $view_mode, $langcode) {
  // We can think about improving this part. Instead of loading 'CSS Class' field
  // styles always. But we need to keep a map of pairs 'entity_type:entity_id' => field
  // So, we can load these styles as required.
  // However, that implementation will be of higher cost
  // and may to worth as it will be only few line of styles from these
  // 'CSS Class' fields in output
  if ($type == 'node') {
    $css_class_fields = media_ckeditor_extras_fields_by_type_by_bundle('file', NULL, 'css_class');
    foreach ($css_class_fields as $field_name) {
      media_ckeditor_extras_add_styles_for_css_field($field_name);
    }
    drupal_add_css(drupal_get_path('module', 'media_ckeditor_extras') . '/css/media-ckeditor-extras.css');
  }
}

/**
 * Implements hook_init()
 */
function media_ckeditor_extras_init() {
  if (arg(0) == 'node' && is_numeric(arg(1)) && empty(arg(2))){
    // We can think about improving this part. Instead of loading 'CSS Class' field
    // styles always. But we need to keep a map of pairs 'entity_type:entity_id' => field
    // So, we can load these styles as required.
    // However, that implementation will be of higher cost
    // and may to worth as it will be only few line of styles from these
    // 'CSS Class' fields in output
    $css_class_fields = media_ckeditor_extras_fields_by_type_by_bundle('file', NULL, 'css_class');
    foreach ($css_class_fields as $field_name) {
      media_ckeditor_extras_add_styles_for_css_field($field_name);
    }
    drupal_add_css(drupal_get_path('module', 'media_ckeditor_extras') . '/css/media-ckeditor-extras.css');
  }
}

/**
 * Implements hook_advanced_help_topic_info_alter().
 */
function media_ckeditor_extras_advanced_help_topic_info_alter(&$ini) {
  // Disabled advance help for this module. We do not support advanced help.
  unset($ini['topics']['media_ckeditor_extras']);
}

/**
 * Implements hook_form_alter()
 */
function media_ckeditor_extras_form_alter(&$form, &$form_state, $form_id) {
  // Hide MCE link and placement fields in froms other than media borwser.
  if ((in_array($form_id, array('file_entity_edit', 'file_entity_add_upload', 'media_internet_add_upload')) || preg_match('/^media_edit_\d+$/', $form_id))
    &&
    isset($form['#entity']->type)
  ) {
    $file_type = $form['#entity']->type;
    $link_field_name = variable_get("media_ckeditor_extras_file_{$file_type}_link", '_none');
    if (!empty($link_field_name) && $link_field_name != '_none' && !empty($form[$link_field_name])) {
      $form[$link_field_name]['#access'] = FALSE;
    }
    if (!empty($form['field_media_placement'])) {
      $form['field_media_placement']['#access'] = FALSE;
    }
  }
}
